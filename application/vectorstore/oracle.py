import logging
from typing import List, Optional, Any, Dict
from application.core.settings import settings
from application.vectorstore.base import BaseVectorStore
from application.vectorstore.document_class import Document


class OracleVectorStore(BaseVectorStore):
    """
    Oracle Database 23ai Vector Store implementation.
    
    Oracle Database 23ai (formerly Oracle 23c) includes native vector search
    capabilities with the VECTOR data type and vector similarity search operators.
    """
    
    def __init__(
        self,
        source_id: str = "",
        embeddings_key: str = "embeddings",
        table_name: str = "documents",
        decoded_token: Optional[str] = None,
        vector_column: str = "embedding",
        text_column: str = "text",
        metadata_column: str = "metadata",
        connection_string: str = None,
    ):
        super().__init__()
        # Store the source_id for use in add_chunk
        self._source_id = str(source_id).replace("application/indexes/", "").rstrip("/")
        self._embeddings_key = embeddings_key
        self._table_name = table_name
        self._vector_column = vector_column
        self._text_column = text_column
        self._metadata_column = metadata_column
        self._embedding = self._get_embeddings(settings.EMBEDDINGS_NAME, embeddings_key)
        
        # Use provided connection string or fall back to settings
        self._connection_string = connection_string or getattr(settings, 'ORACLE_CONNECTION_STRING', None)
        
        if not self._connection_string:
            raise ValueError(
                "Oracle connection string is required. "
                "Set ORACLE_CONNECTION_STRING in settings or pass connection_string parameter. "
                "Format: user/password@hostname:port/service_name or use DSN"
            )

        try:
            import oracledb
        except ImportError:
            raise ImportError(
                "Could not import oracledb package. "
                "Please install with `pip install oracledb`."
            )

        self._oracledb = oracledb
        self._connection = None
        self._ensure_table_exists()

    def _get_connection(self):
        """Get or create database connection"""
        if self._connection is None:
            try:
                # Try to connect using connection string
                # Oracle connection string can be in format: user/password@hostname:port/service_name
                self._connection = self._oracledb.connect(self._connection_string)
            except Exception as e:
                # If connection string format doesn't work, try parsing it
                logging.warning(f"Direct connection failed: {e}, trying alternative method")
                # You might want to parse connection string if needed
                raise ValueError(f"Failed to connect to Oracle: {e}")
        return self._connection

    def _close_connection(self):
        """Close database connection"""
        if self._connection is not None:
            try:
                self._connection.close()
            except Exception:
                pass
            finally:
                self._connection = None

    def _ensure_table_exists(self):
        """Create table and vector index if they don't exist"""
        conn = self._get_connection()
        cursor = conn.cursor()
        
        try:
            # Get embedding dimension
            embedding_dim = getattr(self._embedding, 'dimension', 768)
            if not embedding_dim:
                # Try to get dimension from embedding if available
                try:
                    test_embedding = self._embedding.embed_query("test")
                    embedding_dim = len(test_embedding)
                except Exception:
                    embedding_dim = 768  # Default fallback
            
            # Create table with VECTOR column
            # Oracle 23ai VECTOR type syntax: VECTOR(dimension, format)
            # Format can be: FLOAT32, FLOAT64, BINARY
            create_table_query = f"""
            BEGIN
                EXECUTE IMMEDIATE '
                CREATE TABLE {self._table_name} (
                    id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                    {self._text_column} CLOB NOT NULL,
                    {self._vector_column} VECTOR({embedding_dim}, FLOAT32),
                    {self._metadata_column} CLOB,
                    source_id VARCHAR2(255) NOT NULL,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )';
            EXCEPTION
                WHEN OTHERS THEN
                    IF SQLCODE != -955 THEN  -- ORA-00955: name is already used
                        RAISE;
                    END IF;
            END;
            """
            cursor.execute(create_table_query)
            
            # Create vector index for similarity search
            # Oracle 23ai supports IVFFlat and HNSW index types
            index_name = f"{self._table_name}_{self._vector_column}_idx"
            create_index_query = f"""
            BEGIN
                EXECUTE IMMEDIATE '
                CREATE INDEX {index_name}
                ON {self._table_name} ({self._vector_column})
                INDEXTYPE IS VECTOR_INDEX
                PARAMETERS (''type IVFFlat
                            operation "vector distance (cosine, euclidean)"
                            neighbor_partitions 50'')';
            EXCEPTION
                WHEN OTHERS THEN
                    IF SQLCODE != -955 THEN  -- ORA-00955: name is already used
                        RAISE;
                    END IF;
            END;
            """
            cursor.execute(create_index_query)
            
            # Create index for source_id filtering
            source_index_name = f"{self._table_name}_source_id_idx"
            create_source_index_query = f"""
            BEGIN
                EXECUTE IMMEDIATE '
                CREATE INDEX {source_index_name}
                ON {self._table_name} (source_id)';
            EXCEPTION
                WHEN OTHERS THEN
                    IF SQLCODE != -955 THEN
                        RAISE;
                    END IF;
            END;
            """
            cursor.execute(create_source_index_query)
            
            conn.commit()
            logging.info(f"Oracle table {self._table_name} and indexes created/verified successfully")
            
        except Exception as e:
            conn.rollback()
            logging.error(f"Error creating Oracle table: {e}", exc_info=True)
            raise
        finally:
            cursor.close()

    def _prepare_vector_for_insert(self, vector: List[float]) -> str:
        """
        Convert Python list to Oracle VECTOR format.
        Oracle expects vectors in a specific format for insertion.
        """
        # Oracle VECTOR format: convert list to string representation
        # Format: [v1, v2, v3, ...] or comma-separated values
        vector_str = "[" + ",".join(str(v) for v in vector) + "]"
        return vector_str

    def search(self, question: str, k: int = 2, *args, **kwargs) -> List[Document]:
        """Search for similar documents using vector similarity"""
        query_vector = self._embedding.embed_query(question)
        
        conn = self._get_connection()
        cursor = conn.cursor()
        
        try:
            # Oracle 23ai vector similarity search using VECTOR_DISTANCE function
            # COSINE distance is commonly used for embeddings
            # Format: VECTOR_DISTANCE(vector_column, query_vector, COSINE)
            vector_str = self._prepare_vector_for_insert(query_vector)
            
            search_query = f"""
            SELECT {self._text_column}, {self._metadata_column},
                   VECTOR_DISTANCE({self._vector_column}, :query_vec, COSINE) as distance
            FROM {self._table_name}
            WHERE source_id = :source_id
            ORDER BY VECTOR_DISTANCE({self._vector_column}, :query_vec, COSINE)
            FETCH FIRST :k ROWS ONLY
            """
            
            # Prepare query vector for binding
            # Oracle might need the vector in a specific format for binding
            cursor.execute(
                search_query,
                {
                    "query_vec": query_vector,  # oracledb will handle vector binding
                    "source_id": self._source_id,
                    "k": k
                }
            )
            
            results = cursor.fetchall()
            
            documents = []
            for row in results:
                text = row[0]
                metadata_json = row[1]
                distance = row[2]
                
                # Parse metadata if it's stored as JSON string
                metadata = {}
                if metadata_json:
                    try:
                        import json
                        if isinstance(metadata_json, str):
                            metadata = json.loads(metadata_json)
                        else:
                            metadata = metadata_json
                    except Exception:
                        metadata = {}
                
                documents.append(Document(page_content=text, metadata=metadata))
            
            return documents
            
        except Exception as e:
            logging.error(f"Error searching documents in Oracle: {e}", exc_info=True)
            return []
        finally:
            cursor.close()

    def add_texts(
        self,
        texts: List[str],
        metadatas: Optional[List[Dict[str, Any]]] = None,
        *args,
        **kwargs,
    ) -> List[str]:
        """Add texts with their embeddings to the vector store"""
        if not texts:
            return []

        embeddings = self._embedding.embed_documents(texts)
        metadatas = metadatas or [{}] * len(texts)
        
        conn = self._get_connection()
        cursor = conn.cursor()
        
        try:
            insert_query = f"""
            INSERT INTO {self._table_name} 
            ({self._text_column}, {self._vector_column}, {self._metadata_column}, source_id)
            VALUES (:text, :vector, :metadata, :source_id)
            RETURNING id INTO :id
            """
            
            inserted_ids = []
            
            import json
            for text, embedding, metadata in zip(texts, embeddings, metadatas):
                # Convert metadata to JSON string
                metadata_json = json.dumps(metadata) if metadata else None
                
                # Oracle requires vector in specific format
                # For oracledb, we can bind the vector directly or convert to array
                vector_value = embedding
                
                # Create output variable for RETURNING clause
                output_var = cursor.var(int)
                
                cursor.execute(
                    insert_query,
                    {
                        "text": text,
                        "vector": vector_value,  # oracledb handles vector binding
                        "metadata": metadata_json,
                        "source_id": self._source_id,
                        "id": output_var
                    }
                )
                
                inserted_id = output_var.getvalue()[0]
                inserted_ids.append(str(inserted_id))
            
            conn.commit()
            return inserted_ids
            
        except Exception as e:
            conn.rollback()
            logging.error(f"Error adding texts to Oracle: {e}", exc_info=True)
            raise
        finally:
            cursor.close()

    def delete_index(self, *args, **kwargs):
        """Delete all documents for this source_id"""
        conn = self._get_connection()
        cursor = conn.cursor()
        
        try:
            delete_query = f"DELETE FROM {self._table_name} WHERE source_id = :source_id"
            cursor.execute(delete_query, {"source_id": self._source_id})
            deleted_count = cursor.rowcount
            conn.commit()
            logging.info(f"Deleted {deleted_count} documents for source_id: {self._source_id}")
            
        except Exception as e:
            conn.rollback()
            logging.error(f"Error deleting index in Oracle: {e}", exc_info=True)
            raise
        finally:
            cursor.close()

    def save_local(self, *args, **kwargs):
        """No-op for Oracle - data is already persisted in the database"""
        pass

    def get_chunks(self) -> List[Dict[str, Any]]:
        """Get all chunks for this source_id"""
        conn = self._get_connection()
        cursor = conn.cursor()
        
        try:
            select_query = f"""
            SELECT id, {self._text_column}, {self._metadata_column}
            FROM {self._table_name}
            WHERE source_id = :source_id
            """
            cursor.execute(select_query, {"source_id": self._source_id})
            results = cursor.fetchall()
            
            chunks = []
            import json
            for row in results:
                doc_id = str(row[0])
                text = row[1]
                metadata_json = row[2]
                
                # Parse metadata
                metadata = {}
                if metadata_json:
                    try:
                        if isinstance(metadata_json, str):
                            metadata = json.loads(metadata_json)
                        else:
                            metadata = metadata_json
                    except Exception:
                        metadata = {}
                
                chunks.append({
                    "doc_id": doc_id,
                    "text": text,
                    "metadata": metadata
                })
            
            return chunks
            
        except Exception as e:
            logging.error(f"Error getting chunks from Oracle: {e}", exc_info=True)
            return []
        finally:
            cursor.close()

    def add_chunk(self, text: str, metadata: Optional[Dict[str, Any]] = None) -> str:
        """Add a single chunk to the vector store"""
        metadata = metadata or {}

        final_metadata = metadata.copy()
        final_metadata["source_id"] = self._source_id

        embeddings = self._embedding.embed_documents([text])

        if not embeddings:
            raise ValueError("Could not generate embedding for chunk")
        
        conn = self._get_connection()
        cursor = conn.cursor()
        
        try:
            import json
            metadata_json = json.dumps(final_metadata) if final_metadata else None
            
            insert_query = f"""
            INSERT INTO {self._table_name} 
            ({self._text_column}, {self._vector_column}, {self._metadata_column}, source_id)
            VALUES (:text, :vector, :metadata, :source_id)
            RETURNING id INTO :id
            """
            
            output_var = cursor.var(int)
            
            cursor.execute(
                insert_query,
                {
                    "text": text,
                    "vector": embeddings[0],
                    "metadata": metadata_json,
                    "source_id": self._source_id,
                    "id": output_var
                }
            )
            
            inserted_id = output_var.getvalue()[0]
            conn.commit()
            
            return str(inserted_id)
            
        except Exception as e:
            conn.rollback()
            logging.error(f"Error adding chunk to Oracle: {e}", exc_info=True)
            raise
        finally:
            cursor.close()

    def delete_chunk(self, chunk_id: str) -> bool:
        """Delete a specific chunk by its ID"""
        conn = self._get_connection()
        cursor = conn.cursor()
        
        try:
            delete_query = f"DELETE FROM {self._table_name} WHERE id = :chunk_id AND source_id = :source_id"
            cursor.execute(delete_query, {"chunk_id": int(chunk_id), "source_id": self._source_id})
            deleted_count = cursor.rowcount
            conn.commit()
            
            return deleted_count > 0
            
        except Exception as e:
            conn.rollback()
            logging.error(f"Error deleting chunk from Oracle: {e}", exc_info=True)
            return False
        finally:
            cursor.close()

    def __del__(self):
        """Close database connection when object is destroyed"""
        self._close_connection()
